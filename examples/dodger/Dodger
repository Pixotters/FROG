= Dodger game =

Basic game meant to guide us determining the order of importance between 
modules to implements. It will start with a very basic application and will be 
improved over iterations.

== Synopsis ==

The player controls the mouse, and has to dodge as long as possible the shapes. 

== First iteration ==

=== Game scenario ===

  # Player launches the game
  # Window appears and render the scene
    -- Random shapes appear, representing the "enemies"
  # Player plays (until he dies)
    -- Player uses mouse to move its circle
    -- Enemies move in one direction only, but bounce against the borders
    -- When two enemies collide, they destroy each other
    -- If an enemy collides with the player, he loses. Time is the score. 

=== Modules to implement ===

To produce this game we need to:

  - Open a window
  - Render a simple scene
    -- one panel
    -- simple shapes
       --- player : circle
       --- enemies : squares, circles, (hexagons ?)
  - Handle input
    -- queue inputs
    -- Game loop
       --- react to inputs (during game loop)
           ---- poll inputs
           ---- process inputs
       --- compute new situation
           ---- move entities
           ---- detect collision
           ---- update the timer for the score
       --- render the new situation

Summary:
  - Window
  - Renderer
  - Inputs (mouse)
  - Game loop
  - Timer
  - Collision

==== Window ====

SFML provides a simple way to display a window : the class RenderWindow.  
```
appwindow = new sf::RenderWindow( 
          sf::VideoMode( <width>, <height> ), 
          "title's string", 
          <style> );  
```
Of course, in the future, <width>, <height>, and <style> shoud be customisable 
thanks to a configuration file.

==== Renderer ====

The renderer is linked to the Window. But SFML provides an other way : 
RenderTarget, allowing to dissociate Window display and Rendering.  
RenderTarget can draw objects that extend // sf::Drawable // simply with the 
method `` <rendertarget>.draw(mydrawableobject) ``.
As simple shapes are provided by SFML, We can simply use these shapes as 
bounding boxes to test collisions.

==== Inputs ====

Inputs are handled in a loop : 
```
sf::Event event;
while( <renderwindow>.pollEvent(event) )
{
  if(event.type == sf::Event::Closed)
  {
    // close the application (properly)  
  }else if(event.type ==sf::Event::KeyPressed )
  {
    // search if the key is bound to a valid action
  }
  ...
}
```
Such loops must be redefined in the States.  
We must think about how we associate inputs with actions : association list ? 
I think maps could be a good solution : when a user triggers an input, we just 
search in the map the associated action. 1 input can have only 1 action, but 1 
action can be associated with several inputs.    

==== Game loop ====

The game loop should be simple to implement : 
```
void App::loop(){
  if( <isrunning> )
  {
    <currentState>.handleinputs()
    <currentState>.update()
    <currentState>.render()
  }
}
```
However we must consider the time/framerate related things such as 
//delta time//.

=== Timer ===

Simply a counter increasing by the time. But what can we expect from time ? 
Real time ? Application time ? Game loop's time ? 
If a computer runs on low framerate, does the time pass slower ?  
Maybe all these things are customisable.  
For now, I think I will just add the //delta time// to the counter. 

==== Collision ====

Collision may be the "hardest" part. Especially for this kind of game, where 
various shapes could collide. 
