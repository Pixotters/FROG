= Dodger game =

Basic game meant to guide us determining the order of importance between 
modules to implements. It will start with a very basic application and will be 
improved over iterations.

== Synopsis ==

The player controls the mouse, and has to dodge red shapes while shooting blue shapes. 

== First iteration ==

=== Game mechanics ===

  # Player launches the game
  # Window appears and render the scene
    -- Random shapes appear, representing the "enemies" and the "targets"
  # Player plays (until he dies or time is up)
    -- Player uses mouse to move its circle
    -- Mouse button allow to fire to destroy blue shapes, giving him points
    -- Enemies move in one direction only[, but bounce against the borders ?]
    -- When two enemies collide, they destroy each other
    -- If the player collides with an ennemy, he loses 1 life, after 3 lifes he dies
    -- If the timer falls to 0, the player wins and can enjoy his score.

=== Modules to implement ===

To produce this game we need to:

  - Open a window
  - Render a simple scene
    -- one panel
    -- simple shapes
       --- player : circle
       --- enemies : squares, circles, (hexagons ?)
    -- drawing text (for the timer and lifes)
  - Game loop
    -- react to inputs
        --- poll inputs
        --- check if input is a valid action
        --- process actions
    -- compute new situation
        --- move entities
        --- detect collision
        --- update the timer
    -- render the new situation

Summary:
  - Window
  - Renderer
  - Inputs (mouse)
  - Game loop
  - Timer
  - Collision

==== Window ====

SFML provides a simple way to display a window : the class RenderWindow.  
```
appwindow = new sf::RenderWindow( 
          sf::VideoMode( <width>, <height> ), 
          "title's string", 
          <style> );  
```
Of course, in the future, <width>, <height>, and <style> shoud be customisable 
thanks to a configuration file. This is why we should take care of resolutions, 
by (for instance) normalizing distances (or giving the choice to the user).  

==== Renderer ====

The renderer is linked to the Window. But SFML provides an other way : 
RenderTarget, allowing to dissociate Window display and Rendering.  
RenderTarget can draw objects that extend // sf::Drawable // simply with the 
method `` <rendertarget>.draw(mydrawableobject) ``.
As simple shapes are provided by SFML, We can simply use these shapes as 
bounding boxes to test collisions.  

==== Inputs ====

Inputs are handled in a loop : 
```
sf::Event event;
while( <renderwindow>.pollEvent(event) )
{
  if(event.type == sf::Event::Closed)
  {
    // close the application (properly)  
  }else if(event.type ==sf::Event::KeyPressed )
  {
    // search if the key is bound to a valid action
  }
  ...
}
```
Such loops must be redefined in the States.  
We must think about how we associate inputs with actions : association list ? 
I think maps could be a good solution : when a user triggers an input, we just 
search in the map the associated action. 1 input can have only 1 action, but 1 
action can be associated with several inputs.  
However, we could offer a higher level by implementing an Event system : such 
events could be "X collided", "Y moved", "A as been pressed". Thus, users may 
not take care of SFML's input system.  

==== Game loop ====

The game loop should be simple to implement : 
```
void App::loop(){
  if( <isrunning> )
  {
    <currentState>.handleinputs()
    <currentState>.update()
    <currentState>.render()
  }
}
```
However we must consider the time/framerate related things such as 
//delta time//.

=== Timer ===

Simply a counter increasing by the time. But what can we expect from time ? 
Real time ? Application time ? Game loop's time ? 
If a computer runs on low framerate, does the time pass slower ?  
Maybe all these things are customisable.  
For now, I think I will just add the //delta time// to the counter. 

==== Collision ====

Collision may be the "hardest" part. Especially for this kind of game, where 
various shapes could collide. In relation with waht I said in the //Input// 
section, it may be possible to wrap collision in events. The collider engine 
would compute all collisions, and send messages to concerned objects when they 
collide with something.  
For now, I think I will just test by hand.  
