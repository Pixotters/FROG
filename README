#Projet long de Nicolas Cailloux et Julien Sagot

##Moteur de développement

###Présentation brève

Nous souhaitons développer un moteur de développement d'applications intéractives multimédia (orienté jeu, mais devrait être utilisable pour d'autres types de programme). Le but est de faciliter et accélérer la phase de développement en fournissant des composants redondants : on n'a pas envie de réécrire tout le temps du code. Ainsi, les utilisateurs pourront se concentrer sur les taches plus importantes, comme la conception ou les algorithmes spécifiques à l'application.  

###Détails

Les qualités recherchées pour le moteur sont :   

* Simplicité : le but est d'accélérer le développement d'applications, en fournissant des composants "déjà prêt à l'utilisation", il ne faudrait donc pas gacher ça avec une difficulté d'utilisation freinante.  
* Modularité : on devrait pouvoir utiliser chaque composant le plus indépendamment possible des autres. 
* Extensibilité : on devrait pouvoir ajouter facilement d'autres composants dans le futur (ou simplement pour d'autres développeurs). 
* Abstraction/généricité : le moteur devrait être suffisament générique pour pouvoir être utilisé dans le plus de programmes possibles (ceux-ci étant de type arbitrairement variés). 

###Fonctionnalités

Les composants auquels on a pensé (soit par nous-même, soit par le biais de lectures) sont décrits ci-après. Nous les avons classés selon l'importance qu'ils ont, car si le temps manque, ce sera plus facile de déterminer ce dont on peut se passer et ce qui est indispensable. Cela peut sembler long mais plusieurs fonctionnalités sont en fait faciles et rapides à implémenter.  

####Minimum syndical 
Si nous ne parvenons pas à faire au moins ça, ce serait une monumentale déception.

* **Gestion de la boucle** : le programme calcule la configuration courante (après avoir récupéré les éventuels entrées de l'utilisateur) et donne une représentation de cette configuration. Ceci est repété jusqu'à un moment déterminé (généralement, la fin du programme).  
* **Etats** : gestion des transitions entres états d'un même programme. Par exemple, le splashscreen, le menu principal, le menu d'options (...) sont autant d'états différents, accessibles ou non depuis certains autres états. Ceci fait un automate (implicite) qu'il faut gérer de manière efficace et en symbiose avec le reste des composants.  
* **Ressources** : l'accès aux fichiers est une opération lourde, ainsi on veut les limiter le plus possible, par exemple en ne chargeant pas 2 fois le même fichier en mémoire. De plus, l'accès aux données d'un fichier qui n'a pas été chargé peut poser problème. Il faut gérer ça.  
* **Gestion des entrées** : le principe d'une application intéractive, c'est que l'utilisateur intéragit avec le programme. Il faut donc implémenter ces moyens de communication. 
* **Rendu** : en tous cas, un version minimale du rendu, permettant d'afficher la configuration courante de manière simple, avec des propriétés basiques et classiques comme la position, la rotation, l'échelle. Certaines fonctionnalités de rendu sont plus avancées.  

####Minimum désiré
Nous serons relativement satisfaits si on a réussi à faire tout ceci, car ces composants permettent de faire déjà pas mal de choses.

* **GUI** : une sorte de toolkit pour faire des menus facilement, et pour les intégrer au programme facilement.  
* **Objects** : un modèle extensible d'objets, ainsi que quelques implémentations fournies (à déterminer).   
* **Animations** : l'affichage d'images faisant partie du rendu, il serait pratique de pouvoir les animer à travers le temps. 
* **Graphe de scène** : faisant parti du rendu, permettant de hiérarchiser l'affichage.  
* **Fichiers** : différent des ressources, car ils ne sont pas déterminés à l'avance, et sont aussi accédés en écriture. On pense notamment aux fichiers de configuration ou de sauvegarde. 
* **Son** : simplement le jeu de sons/musiques.

####Composants pratiques
Des fonctionnalités qu'il serait commode d'implémenter car elles se retrouvent souvent. 

* **Collision/physique** : probablement la tache la plus longue, impliquant des algorithme de partionnement de l'espace, de tests de collision, de gestion de forces (gravité, vélocité, masse, ...). A noter qu'une version minimale est obligatoire (pour la GUI : le clic sur les boutons). 
* **Standardisation des cartes** : souvent dans les jeux, on affiche des cartes. Elles peuvent être représentées via des Tiles (élément carré ou hexagonal redondant), ou sous forme de graphe. 
* **Inventaire** : Encore une fois, surtout quelque chose pour les jeux, mais pas seulement. Représente un ensemble d'éléments collectés pendant l'application. 
* **Vues** : Raffinemment des "caméras", permettant de voir plusieurs endroits d'une scène (rendu d'un état) de différentes manières. 

####Composants avancés
Des fonctionnalités soit difficiles, soit longues à implémenter, qui seront ajoutées si on a pu faire tout le reste (ou, après le rendu officiel, si nous continuons le développement).
 
* **Culling** : optimisation consistant à calculer uniquement le rendu de la partie visible via les caméras.
* **Réseau** : permettre la communication distante entre deux applications, sans avoir à mettre en place toute la longue mécanique sous-jacente. Aussi, la résolution de certains problèmes liés (compensation du lag). 
* **Lumière/ombres** : pour l'amélioration du rendu.
 

####Composants très avancés 
Nous n'aurons probablement pas les connaissances ou le temps pour faire ces taches, qui sont moins prioritaires. Nous les mettons pour le futur du projet.

* **Data-driven** : dans l'idéal, proposer un design data-driven serait bien, car les composants seraient modifiable sans avoir à recompiler. Toutefois ceci se limite à quelques taches spécifiques. 
* **Shaders** : altération du rendu avec des procedures.
* **IA** : une IA protozoaire, ou en tous cas au moins un squelette sur lequel l'utilisateur pourrait greffer le code du comportement voulu. 
* **Bases de données sur serveur** : récupération de données sur un serveur, par exemple les informations liées au compte d'un utilisateur, pour déterminer les droits d'accès à certaines parties du programme.
* **Intégration aux réseaux sociaux** : Face au succès de jeux comme FarmVille ou CandyCrush, il semblerait que l'avenir se tourne vers les jeux dits "sociaux". Ainsi une intégration à Facebook serait un plus pour les utilisateurs interessés. 

###Détails d'implémentation

Nous travailleronts en c++. Rien n'est encore bien fixé, mais nous utiliserons probablement une libraire (en tous cas au début) de haut niveau, SFML, afin d'avoir rapidement des retours sur la correction de ce qu'on fait. Le soucis c'est que SFML possède beaucoup de dépendances. Il faudra être le moins dépendant de la librairie possible, de façon à pouvoir en changer facilement bien sûr, mais aussi pour pouvoir s'en passer dans certaines parties, afin d'offrir une plus grande indépendance et modularité aux composants.  
Nous développons tous deux sur Lubuntu