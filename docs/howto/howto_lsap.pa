= How to implement a LSAP collision manager =

FROG proposes a collision manager nammed LSAP, implemented using Sweep 
And Prune algorithm and doubly linked List. Before explaining how to use 
it, let's introduce the ``Collisionable`` and ``ActionManager`` class.

== The ``Collisionable`` interface ==

``Collisionable`` interface defines four methods to implement: ``int 
getXMin()``, ``int getYMin()``, ``int getXMax()`` and ``int getYMax()``. 
These function are needed to create and keep updated the object's bounding 
box. What does it means: you need to implements these methods in all your 
objects you want in your ``LSAP``. When called these functions need to 
return the minimum/maximum bound on x/y axis at the time they are called.

== The ``ActionManager`` interface ==

``ActionManager`` defines two methods: 
- ``void onCollision(Collisionable * o1, Collisionable * o2)``
- ``void onSeparation(Collisionable * o1, Collisionable * o2)``
These functions are going to be called by ``LSAP``. ``onCollision`` is 
used when a new collision is detected, whereas ``onSeparation`` is called 
when two objects which collided do not collide anymore.

The way you manage types belongs to you. See ``test_LSAP.cpp`` file to 
see an example using ``dynamic_cast`` testing.

== The ``LSAP`` thing ==

Your objects implement ``Collisionable`` and you implemented an 
``ActionManager``.

Now you can create your ``LSAP`` using the ``LSAP (ActionManager *)`` 
constructor. The next step would be to add every objects you want to 
manager in your manager using ``addObject(Collisionable *)``.

Any time your object moves, you may/should want to keep your manager 
updated using ``addObject(Collisionable *)``. It will update bounds in 
manager and detect collisions or separations.

Finally, remove objects from the manager using 
``removeObject(Collisionable *)``.
