= 27/04 - fin des vacances =

== Travail mémoire ==
   
Il a été mis en évidence que l'utilisation de pointeurs bruts peut causer pas 
mal de problèmes. De toutes façons, utiliser des pointeurs est toujours un peu 
dangereux. Nous avons modifé certaines parties, soit pour mettre en statique 
certaines choses qui pouvaient l'être, soit pour remplacer des pointeurs bruts 
par des pointeurs intelligents (*std::shared_ptr* et *std::unique_ptr*).  
Nous avons aussi supprimé le Singleton App. Les informations de l'application 
auxquelles on doit accéder sont wrappées dans une struct **AppInfo**, qui est 
passée en paramètre aux états. Ceci permet de réduire la dépendance 
Scene <-> App. 

== Physique ==

== XML ==

D'abord pour charger la configuration de l'application, mais aussi pour charger 
des données (Scene + GameObject), nous avons dû utiliser un parseur XML. 
Nous avions en premier lieu considéré IncredibleXMLParser, mais pour l'obtenir 
il faut envoyer un mail à l'auteur, ce qui est très louche. Nous nous sommes 
finalement portés sur TinyXML 2, qui semble plus répandu. 
La configuration est lancée depuis un fichier .cfg (qui est un fait un fichier 
XML.
On peut aussi définir dans un fichier quelles vont être les textures qui seront 
chargées par une scène. C'est une première étape vers ue conception orientée 
vers les données. Toutefois, tant qu'on n'aura pas fait l'embarcation d'un 
langage de script, on ne pourra pas s'affranchir totalement du code C++. 

== Rendu ==

Le Renderer a été amélioré avec un wrapper pour afficher des images (Component 
*Sprite*), et des animations (Component *Animator*). Le système d'animation lie 
un *Spritesheet* (fichier XML) à une *Texture* (fichier image) pour offrir une 
plus grand flexibilité (utiliser un même spritesheet pour plusieurs images et 
vice-versa, changer l'un des deux en cours de jeu...). 
Il utilise aussi la valeur //layer// du Component Transform, pour afficher les 
objets dans un ordre défini par l'utilisateur (et non pas selon l'ordre 
d'ajout). Attention : ce ne sont pas encore des plans différentiels. De plus, 
cette valeur n'est pas utilisée par le collisionneur pour certaines raisons. 

== Divers ==

Nous avons aussi implémenté plusieurs proxy et wrappers pour simplifier 
l'utilisation. Plus le framework est facile à utiliser, mieux c'est : la 
simplicité est notre priorité.  
Un peu de documentation a aussi été faite, notamment sur les nouvelles choses. 
Des essais ont été faits sur les FSM. Tout fonctionne (changement d'animation 
via cette FSM et non pas par la scène), mais n'est pas très simple à utiliser. 

== Objectifs de la semaine ==

Il va falloir finir une bonne fois pour toutes le Controller : prise en charge 
des inputs en temps réel, abstraction (en vue d'être utilisé aussi pour une IA 
ou un réseau), et éventuellement le changer en Component. 
On devrait aussi avoir le temps de faire des *TileMap* : c'est rapide, en 
supposant qu'elles s'intègrent bien avec le système de collisions. 

= 10/04 - réunion avant vacances = 

Niveau physique, il y a maintenant des collisions selon un point précis. Rien 
n'est encore fourni pour déterminer ce point de collision (du module physique), 
mais la réaction agit sur les vecteurs des forces qui s'appliquent aux objets 
concernés. 
La documentation Doxygen a été complétée. 

== Objectifs des vacances ==

Un travail sur l'utilisation mémoire va être fait, par l'utilisation de 
pointeurs intelligents : en passant un pointeur à une fonction, on ne sait pas 
si il est alloué directement en paramètre, ou avant. On ne peut donc pas savoir 
quand l'objet sera libéré. 
Nous devrions aussi avancer sur la physique. 

= 03/04 =

Le framework est maintenant bien séparé, et compile avec la commande 
"make frog", qui crée des bibliothèques partagées //.so//. 

Un //AssetManager// générique a aussi été réalisé, qui associe un type 
d'identifiant à un type de ressources : AssetManager<string, texture> associe 
une chaine de caractères à une texture. 

Question déploiement, nous avons vu : pkgconfig (--cflags, --libs), autoconf

== Objectif de la semaine ==

Plus de documentation, plus de physique.

= 27/03 =

Nicolas a encore touché au Controller, mais il a promis de ne plus y toucher 
pendant un moment. Il est désormais plus flexible par l'utilisation de deux 
modules templatés réutilisables : Filter et Translator. Le "vieux" Controller 
a été renommé "ControlHandler", le "nouveau" Controller est en fait une classe 
qui encapsule ce ControlHandler et la traduction des Input en Command. Cela 
semble plus facile pour un utilisateur lambda. 

Julien a écrit un ActionManager par defaut (maintient une liste des 
objets en collision), qui n'est pas encore tésté. Il a commencé le travail 
autour de la physique (plus de recherche que de code).

A coté de ça, la documentation a été améliorée, ainsi que le site web : 
[[frog.pixotters.org]] (automatisation de la génération des pages + upload). 

Un renderer basique a aussi été fait : via un RenderingComponent implémentant 
//sf::Drawable// de SFML, le Renderer de la scène sait comment dessiner les 
objets enregistrés, il saura "où" via le component Transform (obligatoire 
pour les gameobjects, de toutes façons). 

== Objectif de la semaine == 

La priorité est la séparation franche du framework. Jusqu'à maintenant, on 
codait sur le jeu de test //Dodger//. Il faut séparer les composants 
spécifiques et faire un makefile pour créer de librairies partagées (//.so//).  
Ensuite, la gestion intelligente de fichiers (//AssetManager//) est une 
étape essentielle avant d'entamer le rendu plus en profondeur.  
La physique basique devrait être refaite, nous esperons pouvoir faire des 
rebonds. 


= 20/03 = 

Le Controller a été abstrait : il y a maintenant une classe AbstractController 
templatée pour les types d'input et d'output. Le Controller actuel est donc 
un AbstractController<Input, Command>. 

Le gestionnaire de collision est utilisable, bien qu'ameliorable (notamment 
au niveau des gestions des actions lors de la detection d'une collision).

Après entretien avec Stefano il semblerait qu'il n'y ait pas plus propre que 
le Visitor pour le multiple dispatch. Celui-ci a suggéré que nous cherchions 
dans //Boost// un sucre pour le visitor.  
Le professeur a aussi demandé à définir nos projets de test par rapport à des 
jeux existants, pour commencer.  
Nicolas se portera sur un remake de //Wild Guns//, alors que Julien aurait 
envie d'un remake de //Full Metal Planete//.

== Objectifs de la semaine ==

Nicolas veut commencer le rendu. 
Julien veut avancer un peu plus sur les collisions. 
Si le rendu est fait rapidement, il faudra commencer à séparer. 

= 13/03 =

Le système de Controller a été amélioré, et marche désormais avec tous les 
périphériques standard : clavier, souris, manette. Il ne reste plus qu'à 
implémenter les différentes manières de traiter les inputs. On doit définir 
des méthodes //handle(Input)// qui seront appelées correctement via un 
Visitor, le C++ ne gérant par défaut le MultipleDispatch.  
Un début de collision a été fait, se basant sur l'algorithme du 
//Sweep&Prune//, implémenté via des listes doublement chainées. 

== Objectifs de la semaine ==

Julien veut faire une gestion de collision utilisable concrètement.  
Nicolas veut finir la gestion des contrôles : il y a probablement un moyen 
plus simple qu'utiliser un visitor. 


= 06/02 =

Les tests (mis en place avec //Boost//) fonctionnent, tout comme la couverture 
de code (utilisant //g++// et //lcov//). 

Le début de la gestion des inputs a été fait : on capte bien les inputs 
clavier, qu'ils soient en temps réel ou en polling (évènements //one-time//).  
Le système utilisé est un dérivé de //publisher/suscriber//, où le State peut 
enregistrer les touches pour lesquelles il a un intérêt, en leur associant une 
action. Le Controller va filter avec ces souscriptions, en envoyant les actions 
déclenchées au State, via le StateManager.  
Les actions sont simplement des sous-classes de la classe abstraite Action, 
devant redéfinir une méthode //execute//.

Le système de Component a été adopté, sans toutefois être fixé sur 
l'implémentation : deux propositions sont candidates, visibles dans les 
diagrammes (components_a et components_b)

Le système de rendu en découlant a été plus ou moins choisi, selon cette 
implémentation. 

Un remaniement de la physique a aussi été fait en parallèle, mais non commité 
car non-prioritaire : les forces ont été factorisées dans des classes 
possédant deux vecteurs (force et accélération).  

== Objectifs de la semaine == 

Julien commencera l'implémentation du moteur de collision. 
Nicolas avancera sur la gestion des évènements.  
Si l'avancée est rapide, un début sur un rendu amélioré pourrait être fait.


= 27/02 (Stefano) =

Un prototype rapide du jeu Dodger a été effectué. Les fonctionnalités 
implémentées sont : la GameLoop, la gestion des States, le système de 
GameObject, une physique de base (forces de translation, de rotation, 
de croissance avec leurs accélérations respectives).  

Le professeur a suggéré que, même si le système de Component est déjà bien car 
flexible, la physique soit factorisée ( 1 component par type de force ?). 
Reste à voir si cela reste cohérent avec la gestion que fait la SFML des 
transformations. 

Concernant le rendu, deux méthodes s'affrontent : 
- l'une utilise des Renderer par type d'objets et des listes d'associations
- l'autre utilise un Component RenderingComponent à qui on fournit une 
procédure de rendu.  
Dans les deux cas, le rendu n'est jamais fait directement par les objets ou la 
scène, mais via un renderer global (géré par la scène). 
Après l'entretien, Stefano a suggéré que la méthode avec Component est plus 
flexible, mais a aussi dit qu'il fallait bien s'assurer d'avoir besoin de cette 
fléxibilité, et donc de définir des cas concrets pour les deux méthodes. 

Pour les tests unitaires, le choix s'est finalement porté sur la librairie 
Boost, qui offre un framework simple d'utilisation (utilisation de macro, 
pas besoin d'hériter d'une classe test et de surcharger des fonctions, comme 
certaines librairies), et est suffisament répandu pour pouvoir trouver de 
l'aide et des tutoriaux facilement. Le framework de tests unitaires de 
google etait aussi candidat mais n'a pas été retenu. 

Quelques tests unitaires triviaux ont été écrits pour la classe ``Player`` du 
jeu //Dodger//, mais le makefile de test est incapable de trouver les sources : 
est-ce que c'est "include ../Makefile.generic" qui ne marche pas ? 

Une fois ce probleme reglé, plus de tests suivront, et l'analyse de la 
couverture sera faite avec ``gcov`` de ``gcc``. 

Concernant les intéractions utilisateurs, il a été proposé par l'enseignant le 
design pattern Publish/suscribe :  
la fenêtre, par défaut, ignore tous les évènements, sauf si un controller lui 
a dit "je suis intéressé par celui-ci".  
Afin de ne pas avoir a créer un controller par objet, le pattern Chain of 
Responsability a été proposé, afin que ce ne soit que la scène (ou plus haut) 
qui s'enregistre auprès du publisher.

== Objectifs de la semaine ==

- Définir une fois pour toutes si on va utiliser des Component ou pas. Tout 
  le reste en dépend. 
- Pour le débat de rendu des objets : 
  Utilisation modulaire via un RenderingComponent ? 
  Utilisation d'une classe d'association pour objet/renderer ?
  -> description de cas concrets d'utilisations afin de nous orienter. 
- Peut-être une version primitive de gestion des inputs. 
- Mettre à jour les spécifications avec ces changements. 


= 20/02 //(Stefano)//=

Nous avons ecrit les spécifications (de maniere informelle) de deux jeux 
afin de voir de suite ce qui peut etre factorise et dessine un diagramme 
temporel des differentes actions des modules pendant une //game loop//.

Un debut de recherche sur les frameworks de tests unitaires pour c++ a 
permit de decouvrir UnitTest++, plus de recherches permettront de fixer 
notre choix dans la semaine.

Les deux jeux sont :  
# **Cat'n'mouse** : Le jeu du chat et de la souris. Le joueur (chat) doit 
  attraper la souris qui se balade dans une pièce avec des murs. Se joue au 
  clavier.  
# Dodger : Jeu de reflèxes, où le joueur doit éviter des objets tout en 
  tirant sur d'autres. Jouable à la souris.  

Les spécifications sont disponibles dans le dossier ``examples``. De grandes 
questions se sont posées sur les évènements et collisions, à débattre.

== Objectifs de la semaine ==

- Ecrire des diagrammes plus standardises (UML) et identifier :
  -- Les dependances entres les modules de la //game loop//.
  -- Identifier ce qui sera facile a modifier dans le futur et ce qui devra 
     etre fixe des le debut.
- Commencer le developpement pour definir les interfaces de facon plus
  concrete. (Pas forcement de jeu fonctionnel, mais au moins les interfaces 
  des modules)
- Choisir un framework de tests unitaires et ecrire les tests necessaires a 
  cette premiere iteration.

== Notes ==

Julien sera au ski du 22/02 au 02/03. Nicolas codera normalement. Julien 
commentera le code et ecrira les tests unitaires pour les modules 
implementes.


= 13/02 //(JBY)// =

Réflexions sur la modularité. Un schéma a été construit.

== Objectifs de la semaine ==

Pour la semaine du 20 spécification d'un jeu minimal (dans ses aspects 
graphiques : proposition un personnage controlé dans des murs avec un 
poursuivant), pour identifier les modules essentiels et envisager un 
calendrier 
de spécification sur les modules essentiels et ensuite un calendrier de 
réalisation.
