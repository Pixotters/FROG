= 03/04 =

Le framework est maintenant bien séparé, et compile avec la commande 
"make frog", qui crée des bibliothèques partagées //.so//. 

Un //AssetManager// générique a aussi été réalisé, qui associe un type 
d'identifiant à un type de ressources : AssetManager<string, texture> associe 
une chaine de caractères à une texture. 



= 27/03 =

Nicolas a encore touché au Controller, mais il a promis de ne plus y toucher 
pendant un moment. Il est désormais plus flexible par l'utilisation de deux 
modules templatés réutilisables : Filter et Translator. Le "vieux" Controller 
a été renommé "ControlHandler", le "nouveau" Controller est en fait une classe 
qui encapsule ce ControlHandler et la traduction des Input en Command. Cela 
semble plus facile pour un utilisateur lambda. 

Julien a écrit un ActionManager par defaut (maintient une liste des 
objets en collision), qui n'est pas encore tésté. Il a commencé le travail 
autour de la physique (plus de recherche que de code).

A coté de ça, la documentation a été améliorée, ainsi que le site web : 
[[frog.pixotters.org]] (automatisation de la génération des pages + upload). 

Un renderer basique a aussi été fait : via un RenderingComponent implémentant 
//sf::Drawable// de SFML, le Renderer de la scène sait comment dessiner les 
objets enregistrés, il saura "où" via le component Transform (obligatoire 
pour les gameobjects, de toutes façons). 

== Objectif de la semaine == 

La priorité est la séparation franche du framework. Jusqu'à maintenant, on 
codait sur le jeu de test //Dodger//. Il faut séparer les composants 
spécifiques et faire un makefile pour créer de librairies partagées (//.so//).  
Ensuite, la gestion intelligente de fichiers (//AssetManager//) est une 
étape essentielle avant d'entamer le rendu plus en profondeur.  
La physique basique devrait être refaite, nous esperons pouvoir faire des 
rebonds. 


= 20/03 = 

Le Controller a été abstrait : il y a maintenant une classe AbstractController 
templatée pour les types d'input et d'output. Le Controller actuel est donc 
un AbstractController<Input, Command>. 

Le gestionnaire de collision est utilisable, bien qu'ameliorable (notamment 
au niveau des gestions des actions lors de la detection d'une collision).

Après entretien avec Stefano il semblerait qu'il n'y ait pas plus propre que 
le Visitor pour le multiple dispatch. Celui-ci a suggéré que nous cherchions 
dans //Boost// un sucre pour le visitor.  
Le professeur a aussi demandé à définir nos projets de test par rapport à des 
jeux existants, pour commencer.  
Nicolas se portera sur un remake de //Wild Guns//, alors que Julien aurait 
envie d'un remake de //Full Metal Planete//.

== Objectifs de la semaine ==

Nicolas veut commencer le rendu. 
Julien veut avancer un peu plus sur les collisions. 
Si le rendu est fait rapidement, il faudra commencer à séparer. 

= 13/03 =

Le système de Controller a été amélioré, et marche désormais avec tous les 
périphériques standard : clavier, souris, manette. Il ne reste plus qu'à 
implémenter les différentes manières de traiter les inputs. On doit définir 
des méthodes //handle(Input)// qui seront appelées correctement via un 
Visitor, le C++ ne gérant par défaut le MultipleDispatch.  
Un début de collision a été fait, se basant sur l'algorithme du 
//Sweep&Prune//, implémenté via des listes doublement chainées. 

== Objectifs de la semaine ==

Julien veut faire une gestion de collision utilisable concrètement.  
Nicolas veut finir la gestion des contrôles : il y a probablement un moyen 
plus simple qu'utiliser un visitor. 


= 06/02 =

Les tests (mis en place avec //Boost//) fonctionnent, tout comme la couverture 
de code (utilisant //g++// et //lcov//). 

Le début de la gestion des inputs a été fait : on capte bien les inputs 
clavier, qu'ils soient en temps réel ou en polling (évènements //one-time//).  
Le système utilisé est un dérivé de //publisher/suscriber//, où le State peut 
enregistrer les touches pour lesquelles il a un intérêt, en leur associant une 
action. Le Controller va filter avec ces souscriptions, en envoyant les actions 
déclenchées au State, via le StateManager.  
Les actions sont simplement des sous-classes de la classe abstraite Action, 
devant redéfinir une méthode //execute//.

Le système de Component a été adopté, sans toutefois être fixé sur 
l'implémentation : deux propositions sont candidates, visibles dans les 
diagrammes (components_a et components_b)

Le système de rendu en découlant a été plus ou moins choisi, selon cette 
implémentation. 

Un remaniement de la physique a aussi été fait en parallèle, mais non commité 
car non-prioritaire : les forces ont été factorisées dans des classes 
possédant deux vecteurs (force et accélération).  

== Objectifs de la semaine == 

Julien commencera l'implémentation du moteur de collision. 
Nicolas avancera sur la gestion des évènements.  
Si l'avancée est rapide, un début sur un rendu amélioré pourrait être fait.


= 27/02 (Stefano) =

Un prototype rapide du jeu Dodger a été effectué. Les fonctionnalités 
implémentées sont : la GameLoop, la gestion des States, le système de 
GameObject, une physique de base (forces de translation, de rotation, 
de croissance avec leurs accélérations respectives).  

Le professeur a suggéré que, même si le système de Component est déjà bien car 
flexible, la physique soit factorisée ( 1 component par type de force ?). 
Reste à voir si cela reste cohérent avec la gestion que fait la SFML des 
transformations. 

Concernant le rendu, deux méthodes s'affrontent : 
- l'une utilise des Renderer par type d'objets et des listes d'associations
- l'autre utilise un Component RenderingComponent à qui on fournit une 
procédure de rendu.  
Dans les deux cas, le rendu n'est jamais fait directement par les objets ou la 
scène, mais via un renderer global (géré par la scène). 
Après l'entretien, Stefano a suggéré que la méthode avec Component est plus 
flexible, mais a aussi dit qu'il fallait bien s'assurer d'avoir besoin de cette 
fléxibilité, et donc de définir des cas concrets pour les deux méthodes. 

Pour les tests unitaires, le choix s'est finalement porté sur la librairie 
Boost, qui offre un framework simple d'utilisation (utilisation de macro, 
pas besoin d'hériter d'une classe test et de surcharger des fonctions, comme 
certaines librairies), et est suffisament répandu pour pouvoir trouver de 
l'aide et des tutoriaux facilement. Le framework de tests unitaires de 
google etait aussi candidat mais n'a pas été retenu. 

Quelques tests unitaires triviaux ont été écrits pour la classe ``Player`` du 
jeu //Dodger//, mais le makefile de test est incapable de trouver les sources : 
est-ce que c'est "include ../Makefile.generic" qui ne marche pas ? 

Une fois ce probleme reglé, plus de tests suivront, et l'analyse de la 
couverture sera faite avec ``gcov`` de ``gcc``. 

Concernant les intéractions utilisateurs, il a été proposé par l'enseignant le 
design pattern Publish/suscribe :  
la fenêtre, par défaut, ignore tous les évènements, sauf si un controller lui 
a dit "je suis intéressé par celui-ci".  
Afin de ne pas avoir a créer un controller par objet, le pattern Chain of 
Responsability a été proposé, afin que ce ne soit que la scène (ou plus haut) 
qui s'enregistre auprès du publisher.

== Objectifs de la semaine ==

- Définir une fois pour toutes si on va utiliser des Component ou pas. Tout 
  le reste en dépend. 
- Pour le débat de rendu des objets : 
  Utilisation modulaire via un RenderingComponent ? 
  Utilisation d'une classe d'association pour objet/renderer ?
  -> description de cas concrets d'utilisations afin de nous orienter. 
- Peut-être une version primitive de gestion des inputs. 
- Mettre à jour les spécifications avec ces changements. 


= 20/02 //(Stefano)//=

Nous avons ecrit les spécifications (de maniere informelle) de deux jeux 
afin de voir de suite ce qui peut etre factorise et dessine un diagramme 
temporel des differentes actions des modules pendant une //game loop//.

Un debut de recherche sur les frameworks de tests unitaires pour c++ a 
permit de decouvrir UnitTest++, plus de recherches permettront de fixer 
notre choix dans la semaine.

Les deux jeux sont :  
# **Cat'n'mouse** : Le jeu du chat et de la souris. Le joueur (chat) doit 
  attraper la souris qui se balade dans une pièce avec des murs. Se joue au 
  clavier.  
# Dodger : Jeu de reflèxes, où le joueur doit éviter des objets tout en 
  tirant sur d'autres. Jouable à la souris.  

Les spécifications sont disponibles dans le dossier ``examples``. De grandes 
questions se sont posées sur les évènements et collisions, à débattre.

== Objectifs de la semaine ==

- Ecrire des diagrammes plus standardises (UML) et identifier :
  -- Les dependances entres les modules de la //game loop//.
  -- Identifier ce qui sera facile a modifier dans le futur et ce qui devra 
     etre fixe des le debut.
- Commencer le developpement pour definir les interfaces de facon plus
  concrete. (Pas forcement de jeu fonctionnel, mais au moins les interfaces 
  des modules)
- Choisir un framework de tests unitaires et ecrire les tests necessaires a 
  cette premiere iteration.

== Notes ==

Julien sera au ski du 22/02 au 02/03. Nicolas codera normalement. Julien 
commentera le code et ecrira les tests unitaires pour les modules 
implementes.


= 13/02 //(JBY)// =

Réflexions sur la modularité. Un schéma a été construit.

== Objectifs de la semaine ==

Pour la semaine du 20 spécification d'un jeu minimal (dans ses aspects 
graphiques : proposition un personnage controlé dans des murs avec un 
poursuivant), pour identifier les modules essentiels et envisager un 
calendrier 
de spécification sur les modules essentiels et ensuite un calendrier de 
réalisation.
