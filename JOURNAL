= 06/02 =




= 27/02 (Stefano) =

Un prototype rapide du jeu Dodger a été effectué. Les fonctionnalités 
implémentées sont : la GameLoop, la gestion des States, le système de 
GameObject, une physique de base (forces de translation, de rotation, 
de croissance avec leurs accélérations respectives).  

Le professeur a suggéré que, même si le système de Component est déjà bien car 
flexible, la physique soit factorisée ( 1 component par type de force ?). 
Reste à voir si cela reste cohérent avec la gestion que fait la SFML des 
transformations. 

Concernant le rendu, deux méthodes s'affrontent : 
- l'une utilise des Renderer par type d'objets et des listes d'associations
- l'autre utilise un Component RenderingComponent à qui on fournit une 
procédure de rendu. 
Dans les deux cas, le rendu n'est jamais fait directement par les objets ou la 
scène, mais via un renderer global (géré par la scène). 
Après l'entretien, Stefano a suggéré que la méthode avec Component est plus 
flexible, mais a aussi dit qu'il fallait bien s'assurer d'avoir besoin de cette 
fléxibilité, et donc de définir des cas concrets pour les deux méthodes. 

Pour les tests unitaires, le choix s'est finalement porté sur la librairie 
Boost, qui offre un framework simple d'utilisation (utilisation de macro, 
pas besoin d'hériter d'une classe test et de surcharger des fonctions, comme 
certaines librairies), et est suffisament répandu pour pouvoir trouver de 
l'aide et des tutoriaux facilement. Le framework de tests unitaires de 
google etait aussi candidat mais n'a pas été retenu. 

Quelques tests unitaires triviaux ont été écrits pour la classe ``Player`` du 
jeu //Dodger//, mais le makefile de test est incapable de trouver les sources : 
est-ce que c'est "include ../Makefile.generic" qui ne marche pas ? 

Une fois ce probleme reglé, plus de tests suivront, et l'analyse de la 
couverture sera faite avec ``gcov`` de ``gcc``. 

Concernant les intéractions utilisateurs, il a été proposé par l'enseignant le 
design pattern Publish/suscribe : 
la fenêtre, par défaut, ignore tous les évènements, sauf si un controller lui 
a dit "je suis intéressé par celui-ci".  
Afin de ne pas avoir a créer un controller par objet, le pattern Chain of 
Responsability a été proposé, afin que ce ne soit que la scène (ou plus haut) 
qui s'enregistre auprès du publisher.

== Objectifs pour la semaine suivante ==

- Définir une fois pour toutes si on va utiliser des Component ou pas. Tout 
  le reste en dépend. 
- Pour le débat de rendu des objets : 
  Utilisation modulaire via un RenderingComponent ? 
  Utilisation d'une classe d'association pour objet/renderer ?
  -> description de cas concrets d'utilisations afin de nous orienter. 
- Peut-être une version primitive de gestion des inputs. 
- Mettre à jour les spécifications avec ces changements. 




= 20/02 //(Stefano)//=

Nous avons ecrit les spécifications (de maniere informelle) de deux jeux 
afin de voir de suite ce qui peut etre factorise et dessine un diagramme 
temporel des differentes actions des modules pendant une //game loop//.

Un debut de recherche sur les frameworks de tests unitaires pour c++ a 
permit de decouvrir UnitTest++, plus de recherches permettront de fixer 
notre choix dans la semaine.

Les deux jeux sont :
# **Cat'n'mouse** : Le jeu du chat et de la souris. Le joueur (chat) doit 
  attraper la souris qui se balade dans une pièce avec des murs. Se joue au 
  clavier.  
# Dodger : Jeu de reflèxes, où le joueur doit éviter des objets tout en 
  tirant sur d'autres. Jouable à la souris.  

Les spécifications sont disponibles dans le dossier ``examples``. De grandes 
questions se sont posées sur les évènements et collisions, à débattre.

== Objectifs pour la semaine suivante ==

- Ecrire des diagrammes plus standardises (UML) et identifier :
  -- Les dependances entres les modules de la //game loop//.
  -- Identifier ce qui sera facile a modifier dans le futur et ce qui devra 
     etre fixe des le debut.
- Commencer le developpement pour definir les interfaces de facon plus
  concrete. (Pas forcement de jeu fonctionnel, mais au moins les interfaces 
  des modules)
- Choisir un framework de tests unitaires et ecrire les tests necessaires a 
  cette premiere iteration.

== Notes ==

Julien sera au ski du 22/02 au 02/03. Nicolas codera normalement. Julien 
commentera le code et ecrira les tests unitaires pour les modules 
implementes.




= 13/02 //(JBY)// =

Réflexions sur la modularité. Un schéma a été construit.

== Objectifs pour la semaine suivante ==

Pour la semaine du 20 spécification d'un jeu minimal (dans ses aspects 
graphiques : proposition un personnage controlé dans des murs avec un 
poursuivant), pour identifier les modules essentiels et envisager un 
calendrier 
de spécification sur les modules essentiels et ensuite un calendrier de 
réalisation.
